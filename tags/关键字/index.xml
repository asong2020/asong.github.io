<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>关键字 on asong的成长记录小屋</title>
    <link>https://asong2020.github.io/tags/%E5%85%B3%E9%94%AE%E5%AD%97/</link>
    <description>Recent content in 关键字 on asong的成长记录小屋</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 05 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://asong2020.github.io/tags/%E5%85%B3%E9%94%AE%E5%AD%97/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go语言中make和new有什么区别？</title>
      <link>https://asong2020.github.io/2021/05/go%E8%AF%AD%E8%A8%80%E4%B8%ADmake%E5%92%8Cnew%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Wed, 05 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://asong2020.github.io/2021/05/go%E8%AF%AD%E8%A8%80%E4%B8%ADmake%E5%92%8Cnew%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</guid>
      <description>前言 哈喽，大家好，我是拖更好久的鸽子asong。因为5.1去找女朋友，所以一直没有时间写文章啦，想着回来就抓紧学习，无奈，依然沉浸在5.1的甜蜜生活中，一拖再拖，就到现在啦。果然女人影响了我拔刀的速度，但是我很喜欢，略略略。 好啦，不撒狗粮了，开始进入正题，今天我们就来探讨一下Go语言中的make和new到底怎么使用？它们又有什么不同？ 分配内存之new 官方文档</description>
    </item>
    
    <item>
      <title>Go语言中两个nil的比较结果是什么？</title>
      <link>https://asong2020.github.io/2021/05/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/</link>
      <pubDate>Wed, 05 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://asong2020.github.io/2021/05/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E4%B8%A4%E4%B8%AAnil%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88/</guid>
      <description>背景 哈喽，大家好，我是asong。前几天在一个交流群里看到了一道非常有意思的面试题，今天把它分享出来，我们先来看一下这个道题： fmt.Println(nil== nil) 两个nil的比较结果是什么？ true、false、还是无法编译？ 大家先思考着，文中揭晓答案。 写在开始：建议你们看一下这个视频：https://www.youtube.com/watch?v=ynoY2xz-F8s 需要翻墙哈，看完这</description>
    </item>
    
    <item>
      <title>Go语言中interface的类型断言实现原理及性能分析</title>
      <link>https://asong2020.github.io/2021/04/go%E8%AF%AD%E8%A8%80%E4%B8%ADinterface%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</link>
      <pubDate>Sun, 18 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://asong2020.github.io/2021/04/go%E8%AF%AD%E8%A8%80%E4%B8%ADinterface%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</guid>
      <description>前言 哈喽，everyBody，我是asong，今天我们一起来探索一下interface的类型断言是如何实现的。我们通常使用interface有两种方式，一种是带方法的interface，一种是空的interface。因为Go中是没有泛型，所以我们可以用空的interface{}来作为一种伪泛型使用，当我们使用到空的interface{}作为入参或返回值时，就</description>
    </item>
    
  </channel>
</rss>
