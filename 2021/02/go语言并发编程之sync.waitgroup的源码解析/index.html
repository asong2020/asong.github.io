<!DOCTYPE html>
<html lang="en-us">
  <head>
    
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.80.0 with theme Tranquilpeak 0.4.8-BETA">
<meta name="author" content="asong">
<meta name="keywords" content="sync.waitGroup, 并发编程, waitGroup, asong, go, golang">
<meta name="description" content="前言 哈喽，大家好，我是asong，这是我并发编程系列的第三篇文章，上一篇我们一起分析了sync.once的使用与实现，今天我们一起来看一看sync.WaitGroup的使用与实现. 快过年了，这是年前最后一篇推文了，待我积累一下，年后加大力度写干货，在这里先预祝大家新春快乐，身体健康，万事如意！ 什么是sync.WaitGroup 官方文档对sync.WatiGr">


<meta property="og:description" content="前言 哈喽，大家好，我是asong，这是我并发编程系列的第三篇文章，上一篇我们一起分析了sync.once的使用与实现，今天我们一起来看一看sync.WaitGroup的使用与实现. 快过年了，这是年前最后一篇推文了，待我积累一下，年后加大力度写干货，在这里先预祝大家新春快乐，身体健康，万事如意！ 什么是sync.WaitGroup 官方文档对sync.WatiGr">
<meta property="og:type" content="article">
<meta property="og:title" content="Go语言并发编程之sync.waitGroup的源码解析">
<meta name="twitter:title" content="Go语言并发编程之sync.waitGroup的源码解析">
<meta property="og:url" content="https://asong2020.github.io/2021/02/go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">
<meta property="twitter:url" content="https://asong2020.github.io/2021/02/go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">
<meta property="og:site_name" content="asong的成长记录小屋">
<meta property="og:description" content="前言 哈喽，大家好，我是asong，这是我并发编程系列的第三篇文章，上一篇我们一起分析了sync.once的使用与实现，今天我们一起来看一看sync.WaitGroup的使用与实现. 快过年了，这是年前最后一篇推文了，待我积累一下，年后加大力度写干货，在这里先预祝大家新春快乐，身体健康，万事如意！ 什么是sync.WaitGroup 官方文档对sync.WatiGr">
<meta name="twitter:description" content="前言 哈喽，大家好，我是asong，这是我并发编程系列的第三篇文章，上一篇我们一起分析了sync.once的使用与实现，今天我们一起来看一看sync.WaitGroup的使用与实现. 快过年了，这是年前最后一篇推文了，待我积累一下，年后加大力度写干货，在这里先预祝大家新春快乐，身体健康，万事如意！ 什么是sync.WaitGroup 官方文档对sync.WatiGr">
<meta property="og:locale" content="zh-cn">

  
    <meta property="article:published_time" content="2021-02-10T00:00:00">
  
  
    <meta property="article:modified_time" content="2021-02-10T00:00:00">
  
  
  
    
      <meta property="article:section" content="Go源码">
    
  
  
    
      <meta property="article:tag" content="并发编程">
    
      <meta property="article:tag" content="sync包">
    
  


<meta name="twitter:card" content="summary">











  <meta property="og:image" content="https://song-oss.oss-cn-beijing.aliyuncs.com/wx/blog_head.jpeg">
  <meta property="twitter:image" content="https://song-oss.oss-cn-beijing.aliyuncs.com/wx/blog_head.jpeg">


    <title>Go语言并发编程之sync.waitGroup的源码解析</title>

    <link rel="icon" href="https://asong2020.github.io/favicon.png">
    

    

    <link rel="canonical" href="https://asong2020.github.io/2021/02/go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css" integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin="anonymous" />
    
    
    <link rel="stylesheet" href="https://asong2020.github.io/css/style-twzjdbqhmnnacqs0pwwdzcdbt8yhv8giawvjqjmyfoqnvazl0dalmnhdkvp7.min.css" />
    
    

    
      
    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="1">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://asong2020.github.io/">asong的成长记录小屋</a>
  </div>
  
    
      <a class="header-right-picture "
         href="https://asong2020.github.io/#about">
    
    
    
      
        <img class="header-picture" src="https://song-oss.oss-cn-beijing.aliyuncs.com/wx/blog_head.jpeg" alt="作者的图片" />
      
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="1">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://asong2020.github.io/#about">
          <img class="sidebar-profile-picture" src="https://song-oss.oss-cn-beijing.aliyuncs.com/wx/blog_head.jpeg" alt="作者的图片" />
        </a>
        <h4 class="sidebar-profile-name">asong</h4>
        
          <h5 class="sidebar-profile-bio">欢迎关注公众号：<strong>Golang梦工厂</strong></h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://asong2020.github.io/categories/">
    
      <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
      
      <span class="sidebar-button-desc">分类</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://asong2020.github.io/tags">
    
      <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
      
      <span class="sidebar-button-desc">标签</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://asong2020.github.io/#about">
    
      <i class="sidebar-button-icon fa fa-lg fa-question"></i>
      
      <span class="sidebar-button-desc">关于</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://asong2020.github.io/post">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">首页</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/asong2020" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-github"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      

    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="1"
        class="
               hasCoverMetaIn
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
            <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title" itemprop="headline">
      Go语言并发编程之sync.waitGroup的源码解析
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2021-02-10T00:00:00Z">
        
  
  
  
  
    10 二月 2021
  

      </time>
    
    
  
  
    <span>发布在</span>
    
      <a class="category-link" href="https://asong2020.github.io/categories/go%e6%ba%90%e7%a0%81">Go源码</a>
    
  

  </div>

</div>
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              <h2 id="前言">前言</h2>
<blockquote>
<p>哈喽，大家好，我是<code>asong</code>，这是我并发编程系列的第三篇文章，上一篇我们一起分析了<a href="https://mp.weixin.qq.com/s/gT9bNsNhU189PsURJyzsmQ"><code>sync.once</code>的使用与实现</a>，今天我们一起来看一看<code>sync.WaitGroup</code>的使用与实现.</p>
<p>快过年了，这是年前最后一篇推文了，待我积累一下，年后加大力度写干货，在这里先预祝大家新春快乐，身体健康，万事如意！</p>
</blockquote>
<h2 id="什么是syncwaitgroup">什么是<code>sync.WaitGroup</code></h2>
<p>官方文档对<code>sync.WatiGroup</code>的描述是：一个<code>waitGroup</code>对象可以等待一组协程结束，也就等待一组<code>goroutine</code>返回。有了<code>sync.Waitgroup</code>我们可以将原本顺序执行的代码在多个<code>Goroutine</code>中并发执行，加快程序处理的速度。其实他与<code>java</code>中的<code>CountdownLatch</code>，阻塞等待所有任务完成之后再继续执行。我们来看官网给的一个例子，这个例子使用<code>waitGroup</code>阻塞主进程，并发获取多个<code>URL</code>，直到完成所有获取：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;sync&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">httpPkg</span> <span style="color:#66d9ef">struct</span>{}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">httpPkg</span>) <span style="color:#a6e22e">Get</span>(<span style="color:#a6e22e">url</span> <span style="color:#66d9ef">string</span>) {}

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">http</span> <span style="color:#a6e22e">httpPkg</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">urls</span> = []<span style="color:#66d9ef">string</span>{
		<span style="color:#e6db74">&#34;http://www.golang.org/&#34;</span>,
		<span style="color:#e6db74">&#34;http://www.google.com/&#34;</span>,
		<span style="color:#e6db74">&#34;http://www.somestupidname.com/&#34;</span>,
	}
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">url</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">urls</span> {
		<span style="color:#75715e">// Increment the WaitGroup counter.
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
		<span style="color:#75715e">// Launch a goroutine to fetch the URL.
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">url</span> <span style="color:#66d9ef">string</span>) {
			<span style="color:#75715e">// Decrement the counter when the goroutine completes.
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
			<span style="color:#75715e">// Fetch the URL.
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Get</span>(<span style="color:#a6e22e">url</span>)
		}(<span style="color:#a6e22e">url</span>)
	}
	<span style="color:#75715e">// Wait for all HTTP fetches to complete.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
}
</code></pre></div><p>首先我们需要声明一个<code>sync.WaitGroup</code>对象，在主<code>gorourine</code>调用<code>Add()</code>方法设置要等待的<code>goroutine</code>数量，每一个<code>Goroutine</code>在运行结束时要调用<code>Done()</code>方法，同时使用<code>Wait()</code>方法进行阻塞直到所有的<code>goroutine</code>完成。</p>
<h2 id="为什么要用syncwaitgroup">为什么要用<code>sync.waitGroup</code></h2>
<p>我们在日常开发中为了提高接口响应时间，有一些场景需要在多个<code>goroutine</code>中做一些互不影响的业务，这样可以节省不少时间，但是需要协调多个<code>goroutine</code>，没有<code>sync.WaitGroup</code>的时候，我们可以使用通道来解决这个问题，我们把主<code>Goroutine</code>当成铜锣扛把子a song，把每一个<code>Goroutine</code>当成一个马仔，<code>asong</code>管理这些马仔，让这些马仔去收保护费，我今天派10个马仔去收保护费，每一个马仔收好了保护费就在账本上打一个✅，当所有马仔都收好了保护费，账本上就被打满了✅，活全被干完了，很出色，然后酒吧走起，浪一浪，全场的消费松公子买单，写成代码可以这样表示：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">exampleImplWaitGroup</span>()  {
	<span style="color:#a6e22e">done</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{}) <span style="color:#75715e">// 收10份保护费
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">count</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">10</span> <span style="color:#75715e">// 10个马仔
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">0</span>;<span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">count</span>;<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>{
		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) {
			<span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() {
				<span style="color:#a6e22e">done</span> <span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">struct</span> {}{}
			}()
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;马仔%d号收保护费\n&#34;</span>,<span style="color:#a6e22e">i</span>)
		}(<span style="color:#a6e22e">i</span>)
	}
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">0</span>;<span style="color:#a6e22e">i</span>&lt; <span style="color:#a6e22e">count</span>;<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>{
		<span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">done</span>
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;马仔%d号已经收完保护费\n&#34;</span>,<span style="color:#a6e22e">i</span>)
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;所有马仔已经干完活了，开始酒吧消费～&#34;</span>)
}
</code></pre></div><p>虽然这样可以实现，但是我们每次使用都要保证主<code>Goroutine</code>最后从通道接收的次数需要与之前其他的<code>Goroutine</code>发送元素的次数相同，实现起来不够优雅，在这种场景下我们就可以选用<code>sync.WaitGroup</code>来帮助我们实现同步。</p>
<h2 id="源码剖析">源码剖析</h2>
<p>前面我们已经知道<code>sync.waitGroup</code>的基本使用了，接下来我们就一起看看他是怎样实现的～，只有知其所以然，才能写出更健壮的代码。</p>
<p>Go version: 1.15.3</p>
<p>首先我们看一下<code>sync.WaitGroup</code>的结构：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// A WaitGroup must not be copied after first use.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">WaitGroup</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">noCopy</span> <span style="color:#a6e22e">noCopy</span>

	<span style="color:#75715e">// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 64-bit atomic operations require 64-bit alignment, but 32-bit
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// compilers do not ensure it. So we allocate 12 bytes and then use
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// the aligned 8 bytes in them as state, and the other 4 as storage
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// for the sema.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">state1</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">uint32</span>
}
</code></pre></div><p>总共就有两个字段，<code>nocopy</code>是为了保证该结构不会被进行拷贝，这是一种保护机制，会在后面进行介绍；<code>state1</code>主要是存储着状态和信号量，这里使用的8字节对齐处理的方式很有意思，我先来一起看看这种处理。</p>
<h3 id="state1状态和信号量处理"><code>state1</code>状态和信号量处理</h3>
<p><code>state1</code>这里总共被分配了<code>12</code>个字节，这里被设计了三种状态：</p>
<ul>
<li>其中对齐的<code>8</code>个字节作为状态，高<code>32</code>位为计数的数量，低<code>32</code>位为等待的<code>goroutine</code>数量</li>
<li>其中的<code>4</code>个字节作为信号量存储</li>
</ul>
<p>提供了<code>(wg *WaitGroup) state() (statep *uint64, semap *uint32)</code>帮助我们从<code>state1</code>字段中取出他的状态和信号量，为什么要这样设计呢？</p>
<p>我们在分析<a href="https://mp.weixin.qq.com/s/PQ06eL8kMWoGXodpnyjNcA"><code>atomic</code></a>和<a href="https://mp.weixin.qq.com/s/nPWvqaQiQ6Z0TaPoqg3t2Q">Go看源码必会知识之unsafe包</a>有说到过，64位原子操作需要64位对齐，但是32位编译器不能保证这一点，所以为了保证<code>waitGroup</code>在<code>32</code>位平台上使用的话，就必须保证在任何时候，<code>64位</code>操作不会报错。所以也就不能分成两个字段来写，考虑到字段顺序不同、平台不同，内存对齐也就不同。因此这里采用动态识别当前我们操作的<code>64</code>位数到底是不是在<code>8</code>字节对齐的位置上面，我们来分析一下<code>state</code>方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// state returns pointers to the state and sema fields stored within wg.state1.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">wg</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">WaitGroup</span>) <span style="color:#a6e22e">state</span>() (<span style="color:#a6e22e">statep</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">uint64</span>, <span style="color:#a6e22e">semap</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">uint32</span>) {
	<span style="color:#66d9ef">if</span> uintptr(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">state1</span>))<span style="color:#f92672">%</span><span style="color:#ae81ff">8</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#66d9ef">return</span> (<span style="color:#f92672">*</span><span style="color:#66d9ef">uint64</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">state1</span>)), <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">state1</span>[<span style="color:#ae81ff">2</span>]
	} <span style="color:#66d9ef">else</span> {
		<span style="color:#66d9ef">return</span> (<span style="color:#f92672">*</span><span style="color:#66d9ef">uint64</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">state1</span>[<span style="color:#ae81ff">1</span>])), <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">state1</span>[<span style="color:#ae81ff">0</span>]
	}
}
</code></pre></div><p>当数组的首地址是处于一个<code>8</code>字节对齐的位置上时，那么就将这个数组的前<code>8</code>个字节作为<code>64</code>位值使用表示状态，后<code>4</code>个字节作为<code>32</code>位值表示信号量(<code>semaphore</code>)。同理如果首地址没有处于<code>8</code>字节对齐的位置上时，那么就将前<code>4</code>个字节作为<code>semaphore</code>，后<code>8</code>个字节作为<code>64</code>位数值。画个图表示一下：</p>
<p><img src="./images/waitgroup-1.png" alt=""></p>
<h2 id="adddone方法"><code>Add()</code>、<code>Done()</code>方法</h2>
<p><code>sync.WaitGroup</code>提供了<code>Add()</code>方法增加一个计数器，<code>Done()</code>方法减掉一个计数，<code>Done()</code>方法实现比较简单，内部调用的<code>Add()</code>方法实现的计数器减一操作，也就是增减逻辑都在<code>Add()</code>方法中，所以我们重点看一下<code>Add()</code>是如何实现的：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">wg</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">WaitGroup</span>) <span style="color:#a6e22e">Add</span>(<span style="color:#a6e22e">delta</span> <span style="color:#66d9ef">int</span>) {
  <span style="color:#75715e">// 获取状态(Goroutine Counter 和 Waiter Counter)和信号量
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">statep</span>, <span style="color:#a6e22e">semap</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">state</span>()
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">race</span>.<span style="color:#a6e22e">Enabled</span> {
		<span style="color:#a6e22e">_</span> = <span style="color:#f92672">*</span><span style="color:#a6e22e">statep</span> <span style="color:#75715e">// trigger nil deref early
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">delta</span> &lt; <span style="color:#ae81ff">0</span> {
			<span style="color:#75715e">// Synchronize decrements with Wait.
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">race</span>.<span style="color:#a6e22e">ReleaseMerge</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">wg</span>))
		}
		<span style="color:#a6e22e">race</span>.<span style="color:#a6e22e">Disable</span>()
		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">race</span>.<span style="color:#a6e22e">Enable</span>()
	}
  <span style="color:#75715e">// 原子操作，goroutine counter累加delta
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">state</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">AddUint64</span>(<span style="color:#a6e22e">statep</span>, uint64(<span style="color:#a6e22e">delta</span>)<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">32</span>)
  <span style="color:#75715e">// 获取当前goroutine counter的值(高32位)
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> int32(<span style="color:#a6e22e">state</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">32</span>)
  <span style="color:#75715e">// 获取当前waiter counter的值(低32位)
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">w</span> <span style="color:#f92672">:=</span> uint32(<span style="color:#a6e22e">state</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">race</span>.<span style="color:#a6e22e">Enabled</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">delta</span> &gt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">==</span> int32(<span style="color:#a6e22e">delta</span>) {
		<span style="color:#75715e">// The first increment must be synchronized with Wait.
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// Need to model this as a read, because there can be
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// several concurrent wg.counter transitions from 0.
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">race</span>.<span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">semap</span>))
	}
  <span style="color:#75715e">// Goroutine counter是不允许为负数的，否则会发生panic
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v</span> &lt; <span style="color:#ae81ff">0</span> {
		panic(<span style="color:#e6db74">&#34;sync: negative WaitGroup counter&#34;</span>)
	}
  <span style="color:#75715e">// 当wait的Goroutine不为0时，累加后的counter值和delta相等,说明Add()和Wait()同时调用了,所以发生panic,因为正确的做法是先Add()后Wait()，也就是已经调用了wait()就不允许再添加任务了
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">w</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">delta</span> &gt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">==</span> int32(<span style="color:#a6e22e">delta</span>) {
		panic(<span style="color:#e6db74">&#34;sync: WaitGroup misuse: Add called concurrently with Wait&#34;</span>)
	}
  <span style="color:#75715e">// 正常`Add()`方法后，`goroutine Counter`计数器大于0或者`waiter Counter`计数器等于0时，不需要释放信号量
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v</span> &gt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">w</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#66d9ef">return</span>
	}
	<span style="color:#75715e">// 能走到这里说明当前Goroutine Counter计数器为0，Waiter Counter计数器大于0, 到这里数据也就是允许发生变动了，如果发生变动了，则出发panic
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">statep</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">state</span> {
		panic(<span style="color:#e6db74">&#34;sync: WaitGroup misuse: Add called concurrently with Wait&#34;</span>)
	}
	<span style="color:#75715e">// 重置状态，并发出信号量告诉wait所有任务已经完成
</span><span style="color:#75715e"></span>	<span style="color:#f92672">*</span><span style="color:#a6e22e">statep</span> = <span style="color:#ae81ff">0</span>
	<span style="color:#66d9ef">for</span> ; <span style="color:#a6e22e">w</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">w</span><span style="color:#f92672">--</span> {
		<span style="color:#a6e22e">runtime_Semrelease</span>(<span style="color:#a6e22e">semap</span>, <span style="color:#66d9ef">false</span>, <span style="color:#ae81ff">0</span>)
	}
}
</code></pre></div><p>上面的代码有一部分是<code>race</code>静态检测，下面的分析会省略这一部分，因为它并不是本文的重点。</p>
<p>注释我都添加到对应的代码行上了，你是否都看懂了，没看懂不要紧，因为<code>Add()</code>是与<code>Wait()</code>方法一块使用的，所以有些逻辑与<code>wait()</code>里的逻辑是相互照应的，所以当我们看完<code>wait()</code>方法的实现在总结一下你们就明白了。</p>
<h3 id="wait方法"><code>Wait()</code>方法</h3>
<p><code>sync.Wait()</code>方法会阻塞主<code>Goroutine</code>直到<code>WaitGroup</code>计数器变为0。我们一起来看一下<code>Wait()</code>方法的源码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// Wait blocks until the WaitGroup counter is zero.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">wg</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">WaitGroup</span>) <span style="color:#a6e22e">Wait</span>() {
  <span style="color:#75715e">// 获取状态(Goroutine Counter 和 Waiter Counter)和信号量
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">statep</span>, <span style="color:#a6e22e">semap</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">state</span>()
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">race</span>.<span style="color:#a6e22e">Enabled</span> {
		<span style="color:#a6e22e">_</span> = <span style="color:#f92672">*</span><span style="color:#a6e22e">statep</span> <span style="color:#75715e">// trigger nil deref early
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">race</span>.<span style="color:#a6e22e">Disable</span>()
	}
	<span style="color:#66d9ef">for</span> {
    <span style="color:#75715e">// 使用原子操作读取state，是为了保证Add中的写入操作已经完成
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">state</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">LoadUint64</span>(<span style="color:#a6e22e">statep</span>)
    <span style="color:#75715e">// 获取当前goroutine counter的值(高32位)
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> int32(<span style="color:#a6e22e">state</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">32</span>)
     <span style="color:#75715e">// 获取当前waiter counter的值(低32位)
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">w</span> <span style="color:#f92672">:=</span> uint32(<span style="color:#a6e22e">state</span>)
    <span style="color:#75715e">// 如果没有任务，或者任务已经在调用`wait`方法前已经执行完成了，就不用阻塞了
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
			<span style="color:#75715e">// Counter is 0, no need to wait.
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">race</span>.<span style="color:#a6e22e">Enabled</span> {
				<span style="color:#a6e22e">race</span>.<span style="color:#a6e22e">Enable</span>()
				<span style="color:#a6e22e">race</span>.<span style="color:#a6e22e">Acquire</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">wg</span>))
			}
			<span style="color:#66d9ef">return</span>
		}
		<span style="color:#75715e">// 使用CAS操作对`waiter Counter`计数器进行+1操作，外面有for循环保证这里可以进行重试操作
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">CompareAndSwapUint64</span>(<span style="color:#a6e22e">statep</span>, <span style="color:#a6e22e">state</span>, <span style="color:#a6e22e">state</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) {
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">race</span>.<span style="color:#a6e22e">Enabled</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">w</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
				<span style="color:#75715e">// Wait must be synchronized with the first Add.
</span><span style="color:#75715e"></span>				<span style="color:#75715e">// Need to model this is as a write to race with the read in Add.
</span><span style="color:#75715e"></span>				<span style="color:#75715e">// As a consequence, can do the write only for the first waiter,
</span><span style="color:#75715e"></span>				<span style="color:#75715e">// otherwise concurrent Waits will race with each other.
</span><span style="color:#75715e"></span>				<span style="color:#a6e22e">race</span>.<span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">semap</span>))
			}
      <span style="color:#75715e">// 在这里获取信号量，使线程进入睡眠状态，与Add方法中最后的增加信号量相对应，也就是当最后一个任务调用Done方法
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// 后会调用Add方法对goroutine counter的值减到0，就会走到最后的增加信号量
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">runtime_Semacquire</span>(<span style="color:#a6e22e">semap</span>)
      <span style="color:#75715e">// 在Add方法中增加信号量时已经将statep的值设为0了，如果这里不是0，说明在wait之后又调用了Add方法，使用时机不对，触发panic
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">statep</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
				panic(<span style="color:#e6db74">&#34;sync: WaitGroup is reused before previous Wait has returned&#34;</span>)
			}
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">race</span>.<span style="color:#a6e22e">Enabled</span> {
				<span style="color:#a6e22e">race</span>.<span style="color:#a6e22e">Enable</span>()
				<span style="color:#a6e22e">race</span>.<span style="color:#a6e22e">Acquire</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">wg</span>))
			}
			<span style="color:#66d9ef">return</span>
		}
	}
}

</code></pre></div><h3 id="源码总结">源码总结</h3>
<p>分了源码，我们可以总结如下：</p>
<ul>
<li><code>Add</code>方法与<code>wait</code>方法不可以并发同时调用，<code>Add</code>方法要在<code>wait</code>方法之前调用.</li>
<li><code>Add()</code>设置的值必须与实际等待的<code>goroutine</code>个数一致，否则会<code>panic</code>.</li>
<li>调用了<code>wait</code>方法后，必须要在<code>wait</code>方法返回以后才能再次重新使用<code>waitGroup</code>，也就是<code>Wait</code>没有返回之前不要在调用<code>Add</code>方法，否则会发生<code>Panic</code>.</li>
<li><code>Done</code> 只是对<code>Add</code> 方法的简单封装，我们可以向 <code>Add</code>方法传入任意负数（需要保证计数器非负）快速将计数器归零以唤醒等待的 <code>Goroutine</code>.</li>
<li><code>waitGroup</code>对象只能有一份，不可以拷贝给其他变量，否则会造成意想不到的<code>Bug</code>.</li>
</ul>
<h2 id="no-copy机制"><code>no copy</code>机制</h2>
<p>在前文看<code>waitGroup</code>结构时，有一个<code>nocopy</code>字段，为什么要有<code>nocopy</code>呢？我们先看这样一个例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">User</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">Name</span> <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">Info</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Info</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Info</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">Age</span> <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">Number</span> <span style="color:#66d9ef">int</span>
}


<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>()  {
	<span style="color:#a6e22e">u</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">User</span>{
		<span style="color:#a6e22e">Name</span>: <span style="color:#e6db74">&#34;asong&#34;</span>,
		<span style="color:#a6e22e">Info</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Info</span>{
			<span style="color:#a6e22e">Age</span>: <span style="color:#ae81ff">10</span>,
			<span style="color:#a6e22e">Number</span>: <span style="color:#ae81ff">24</span>,
		},
	}
	<span style="color:#a6e22e">u1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">u</span>
	<span style="color:#a6e22e">u1</span>.<span style="color:#a6e22e">Name</span> = <span style="color:#e6db74">&#34;Golang梦工厂&#34;</span>
	<span style="color:#a6e22e">u1</span>.<span style="color:#a6e22e">Info</span>.<span style="color:#a6e22e">Age</span> = <span style="color:#ae81ff">30</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">u</span>.<span style="color:#a6e22e">Info</span>.<span style="color:#a6e22e">Age</span>,<span style="color:#a6e22e">u</span>.<span style="color:#a6e22e">Name</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">u1</span>.<span style="color:#a6e22e">Info</span>.<span style="color:#a6e22e">Age</span>,<span style="color:#a6e22e">u1</span>.<span style="color:#a6e22e">Name</span>)
}
<span style="color:#75715e">// 运行结果
</span><span style="color:#75715e"></span><span style="color:#ae81ff">30</span> <span style="color:#a6e22e">asong</span>
<span style="color:#ae81ff">30</span> <span style="color:#a6e22e">Golang梦工厂</span>
</code></pre></div><p>结构体<code>User</code>中有两个字段<code>Name</code>和<code>Info</code>，<code>Name</code>是<code>String</code>类型，<code>Info</code>是指向结构体<code>Info</code>的指针类型，我们首先声明了一个<code>u</code>变量，对他进行复制拷贝得到变量<code>u1</code>，在<code>u1</code>中对两个字段进行改变，可以看到<code>Info</code>字段发生了更改，而<code>Name</code>就没发生更改，这就引发了安全问题，如果结构体对象包含指针字段，当该对象被拷贝时，会使得两个对象中的指针字段变得不再安全。</p>
<p><code>Go</code>语言中提供了两种<code>copy</code>检查，一种是在运行时进行检查，一种是通过静态检查。不过运行检查是比较影响程序的执行性能的，Go官方目前只提供了strings.Builder和sync.Cond的runtime拷贝检查机制，对于其他需要nocopy对象类型来说，使用go vet工具来做静态编译检查。运行检查的实现可以通过比较所属对象是否发生变更就可以判断，而静态检查是提供了一个<code>nocopy</code>对象，只要是该对象或对象中存在<code>nocopy</code>字段，他就实现了<code>sync.Locker</code>接口, 它拥有Lock()和Unlock()方法，之后，可以通过go vet功能，来检查代码中该对象是否有被copy。</p>
<h2 id="踩坑事项">踩坑事项</h2>
<p>在文章的最后总结一下使用<code>waitGroup</code>易错的知识点，防止大家再次犯错。</p>
<ol>
<li><code>waitGroup</code>中计数器的值是不能小于0的，源码中我们就可以看到，一旦小于0就会引发panic。</li>
<li>一定要住注意调用<code>Add</code>方法与<code>Wait</code>方法的顺序，不可并发同时调用这两个方法，否则就会引发panic，同时在调用了<code>wait</code>方法在其没有释放前不要再次调用<code>Add</code>方法，这样也会引发<code>panic</code>，<code>waitGroup</code>是可以复用的，但是需要保证其计数周期的完整性。</li>
<li><code>WaitGroup</code>对象不是一个引用类型，通过函数传值的时候需要使用地址，因为<code>Go</code>语言只有值传递，传递<code>WaitGroup</code>是值的话，就会导致会发生<code>panic</code>，看这样一个例子：</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>()  {
	<span style="color:#a6e22e">wg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>{}
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
	<span style="color:#a6e22e">doDeadLock</span>(<span style="color:#a6e22e">wg</span>)
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doDeadLock</span>(<span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>)  {
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;do something&#34;</span>)
}
<span style="color:#75715e">//运行结果：panic: sync: negative WaitGroup counter
</span></code></pre></div><p>发生这个问题的原因就是在<code>doDeadLock()</code>方法中<code>wg</code>是一个新对象，直接调用<code>Done</code>方法，计数器就会出现负数，所以引发<code>panic</code>，为了安全起见，对于这种传结构体的场景一般建议都传指针就好了，基本可以避免一些问题。</p>
<ol start="4">
<li>Add()设置的值必须与实际等待的goroutine个数一致，否则会<code>panic</code>，很重要的一点，也是很容易出错的地方。</li>
</ol>
<h2 id="思考题">思考题</h2>
<p>最后给大家出一个思考题，下面这段代码会不会发生<code>panic</code>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">wg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>{}
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">100</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">100</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
			<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>)
		}()
	}
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
}
</code></pre></div><h2 id="结尾">结尾</h2>
<p><strong>在最后，祝大家新年快乐，心想事成，万事如意～～～</strong></p>
<p><strong>好啦，这篇文章就到这里啦，素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！</strong></p>
<p><strong>创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：加我vx拉你入群，或者公众号获取入群二维码</strong></p>
<p><strong>结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。</strong></p>
<p><strong>我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。</strong></p>
<p><strong>翻译了一份Machinery中文文档，会定期进行维护，有需要的小伙伴们后台回复[machinery]即可获取。</strong></p>
<p>**我是asong，一名普普通通的程序猿，让我们一起慢慢变强吧。欢迎各位的关注，我们下期见~~~**</p>
<p><img src="https://song-oss.oss-cn-beijing.aliyuncs.com/wx/qrcode_for_gh_efed4775ba73_258.jpg" alt=""></p>
<p>推荐往期文章：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/nPWvqaQiQ6Z0TaPoqg3t2Q">Go看源码必会知识之unsafe包</a></li>
<li><a href="https://mp.weixin.qq.com/s/mzSCWI8C_ByIPbb07XYFTQ">源码剖析panic与recover，看不懂你打我好了！</a></li>
<li><a href="https://mp.weixin.qq.com/s/PQ06eL8kMWoGXodpnyjNcA">详解并发编程基础之原子操作(atomic包)</a></li>
<li><a href="https://mp.weixin.qq.com/s/FUmoBB8OHNSfy7STR0GsWw">详解defer实现机制</a></li>
<li><a href="https://mp.weixin.qq.com/s/sO6Phr9C5VwcSTQQjJux3g">真的理解interface了嘛</a></li>
<li><a href="https://mp.weixin.qq.com/s/wURQFRt2ISz66icW7jbHFw">Leaf—Segment分布式ID生成系统（Golang实现版本）</a></li>
<li><a href="https://mp.weixin.qq.com/s/rZBsoKuS-ORvV3kML39jKw">十张动图带你搞懂排序算法(附go实现代码)</a></li>
<li><a href="https://mp.weixin.qq.com/s/JHbFh2GhoKewlemq7iI59Q">go参数传递类型</a></li>
<li><a href="https://mp.weixin.qq.com/s/0MykGst1e2pgnXXUjojvhQ">手把手教姐姐写消息队列</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIzMDU0MTA3Nw==&amp;mid=2247483988&amp;idx=1&amp;sn=3bd52650907867d65f1c4d5c3cff8f13&amp;chksm=e8b0902edfc71938f7d7a29246d7278ac48e6c104ba27c684e12e840892252b0823de94b94c1&amp;token=1558933779&amp;lang=zh_CN#rd">常见面试题之缓存雪崩、缓存穿透、缓存击穿</a></li>
<li><a href="https://mp.weixin.qq.com/s/JKMHUpwXzLoSzWt_ElptFg">详解Context包，看这一篇就够了！！！</a></li>
<li><a href="https://mp.weixin.qq.com/s/mV2hnfctQuRLRKpPPT9XRw">go-ElasticSearch入门看这一篇就够了(一)</a></li>
<li><a href="https://mp.weixin.qq.com/s/G7z80u83LTgLyfHgzgrd9g">面试官：go中for-range使用过吗？这几个问题你能解释一下原因吗</a></li>
</ul>

              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">标签</span><br/>
                    
  <a class="tag tag--primary tag--small" href="https://asong2020.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a>

  <a class="tag tag--primary tag--small" href="https://asong2020.github.io/tags/sync%E5%8C%85/">sync包</a>

                  </div>
                
              
            
            <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://asong2020.github.io/2021/03/go%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93unsafe%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" data-tooltip="Go语言标准库unsafe包源码解析">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--disabled">
              
                  <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
      
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

            
              
            
          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2021 asong. All Rights Reserved
  </span>
  <script src="https://utteranc.es/client.js"
          repo="liangyuanpeng/liangyuanpeng.github.io"
          issue-term="title"
          theme="github-light"
          crossorigin="anonymous"
          async>
  </script>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="1">
        <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://asong2020.github.io/2021/03/go%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93unsafe%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" data-tooltip="Go语言标准库unsafe包源码解析">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--disabled">
              
                  <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
      
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="1">
  <i id="btn-close-shareoptions" class="fa fa-close"></i>
  <ul class="share-options">
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="https://song-oss.oss-cn-beijing.aliyuncs.com/wx/blog_head.jpeg" alt="作者的图片" />
    
    <h4 id="about-card-name">asong</h4>
    
      <div id="about-card-bio">欢迎关注公众号：<strong>Golang梦工厂</strong></div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        后端开发工程师
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        深圳
      </div>
    
  </div>
</div>

    

    
  
    
      <div id="cover" style="background-image:url('https://asong2020.github.io/images/cover.jpg');"></div>
    
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js" integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin="anonymous"></script>


<script src="https://asong2020.github.io/js/script-pcw6v3xilnxydl1vddzazdverrnn9ctynvnxgwho987mfyqkuylcb1nlt.min.js"></script>


<script lang="javascript">
window.onload = updateMinWidth;
window.onresize = updateMinWidth;
document.getElementById("sidebar").addEventListener("transitionend", updateMinWidth);
function updateMinWidth() {
  var sidebar = document.getElementById("sidebar");
  var main = document.getElementById("main");
  main.style.minWidth = "";
  var w1 = getComputedStyle(main).getPropertyValue("min-width");
  var w2 = getComputedStyle(sidebar).getPropertyValue("width");
  var w3 = getComputedStyle(sidebar).getPropertyValue("left");
  main.style.minWidth = `calc(${w1} - ${w2} - ${w3})`;
}
</script>

<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>


  
    
  


  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS_CHTML-full" integrity="sha256-GhM+5JHb6QUzOQPXSJLEWP7R73CbkisjzK5Eyij4U9w=" crossorigin="anonymous"></script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      CommonHTML: { linebreaks: { automatic: true } },
      tex2jax: { inlineMath: [ ['$', '$'], ['\\(','\\)'] ], displayMath: [ ['$$','$$'], ['\\[', '\\]'] ], processEscapes: false },
      messageStyle: 'none'
    });
  </script>



    
  </body>
</html>

